using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Kenova.SourceGenerators
{

    [Generator]
    public class Generator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            //context.RegisterForPostInitialization((i) => i.AddSource("...", attributeText));

            // Register a syntax receiver that will be created for each generation pass
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());

        }

        public void Execute(GeneratorExecutionContext context)
        {
            // retrieve the populated receiver 
            SyntaxReceiver receiver = context.SyntaxContextReceiver as SyntaxReceiver;

            if (receiver == null)
                return;

            const string ALSO_ATTRIB = "Kenova.Client.Components.AlsoNotifyAttribute";

            INamedTypeSymbol attrAlsoSymbol = context.Compilation.GetTypeByMetadataName(ALSO_ATTRIB);

            foreach (var vmtg in receiver.ViewModelsToGenerate)
            {
                string classSource = ProcessClass(vmtg, attrAlsoSymbol, context);

                context.AddSource($"{vmtg.ViewModelClassSymbol.Name}_viewModel.cs", SourceText.From(classSource, Encoding.UTF8));
            }

        }

        protected const string TAB = "\t";

        private string ProcessClass(ViewModelToGenerate vmtg, INamedTypeSymbol attrAlsoSymbol, GeneratorExecutionContext context)
        {
            INamedTypeSymbol classSymbol = vmtg.ViewModelClassSymbol;

            string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // begin building the generated source
            var sb = new StringBuilder();

            sb.AppendLine("using Kenova.Client.Components;");
            sb.AppendLine();
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine(@"{");
            sb.AppendLine(TAB + $"public partial class {classSymbol.Name} : ModelTypedBase<{classSymbol.Name}>");
            sb.AppendLine(TAB + "{");

            // if the class doesn't implement INotifyPropertyChanged already, add it
            //if (!classSymbol.Interfaces.Contains(notifySymbol))
            //    sb.AppendLine(TAB + TAB + "public event PropertyChangedEventHandler PropertyChanged;");

            foreach (var prop in vmtg.PropertiesToGenerate)
            {
                generateProperty(sb, prop, attrAlsoSymbol);
            }

            sb.AppendLine(TAB + "}");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private void generateProperty(StringBuilder sb, PropertyToGenerate prop, INamedTypeSymbol attrAlsoSymbol)
        {
            IFieldSymbol fieldSymbol = prop.FieldSymbol;

            // get the name and type of the field
            string fieldName = fieldSymbol.Name;
            ITypeSymbol fieldType = fieldSymbol.Type;

            var extra_notify = new List<string>();

            var also_attr_list = fieldSymbol.GetAttributes().Where(ad => ad.AttributeClass.Equals(attrAlsoSymbol, SymbolEqualityComparer.Default));

            foreach (AttributeData data in also_attr_list)
            {
                //if (data.NamedArguments.Length > 0)
                //    sb.AppendLine("#error Kenova.SourceGenerators does not support named arguments for attributes");

                if (data.ConstructorArguments.Length >= 1)
                {
                    string val = data.ConstructorArguments[0].Value.ToString();
                    extra_notify.Add(val);
                }

            }

            string propertyName = fieldName.TrimStart('_');

            sb.AppendLine();
            sb.AppendLine(TAB + TAB + "/// <summary>");
            sb.AppendLine(TAB + TAB + "/// Property generated by Kenova.SourceGenerators");
            sb.AppendLine(TAB + TAB + "/// </summary>");

            sb.AppendLine(TAB + TAB + $"public {fieldType} {propertyName}");
            sb.AppendLine(TAB + TAB + "{");
            sb.AppendLine(TAB + TAB + TAB + $"get {{ return this.{fieldName}; }}");
            sb.AppendLine(TAB + TAB + TAB + "set");
            sb.AppendLine(TAB + TAB + TAB + "{");
            sb.AppendLine(TAB + TAB + TAB + TAB + $"this.{fieldName} = value;");
            sb.AppendLine(TAB + TAB + TAB + TAB + $"this.NotifyPropertyChanged(nameof({propertyName}));");

            foreach (var name in extra_notify)
                sb.AppendLine(TAB + TAB + TAB + TAB + $"this.NotifyPropertyChanged(\"{name}\");");

            sb.AppendLine(TAB + TAB + TAB + "}");
            sb.AppendLine(TAB + TAB + "}");

        }

    }
}
